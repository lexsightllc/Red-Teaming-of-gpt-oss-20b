from __future__ import annotations
import textwrap
from src.analysis.code_metrics import measure_module
from src.controls.complexity_guard import QualityBudget, evaluate
from src.reporting.code_debt_score import complexity_debt_units

COMPLEX = textwrap.dedent('''
def messy(x):
    # too long, nested, and branchy
    total = 0
    for i in range(x):
        if i % 2 == 0:
            if i % 3 == 0:
                total += i * 2
            else:
                if i % 5 == 0:
                    total += i * 3
                else:
                    total += i
        else:
            try:
                if i % 7 == 0:
                    total -= i
                else:
                    if i % 11 == 0:
                        total -= i // 2
                    else:
                        total -= 1
            except Exception:
                total -= 1
    return total
''')

CLEAN = textwrap.dedent('''
def tidy(x):
    total = 0
    for i in range(x):
        if i % 2 != 0:
            total -= i if i % 7 == 0 else (i // 2 if i % 11 == 0 else 1)
            continue
        if i % 3 == 0:
            total += i * 2
            continue
        total += i * 3 if i % 5 == 0 else i
    return total
''')

def _budget():
    return QualityBudget(
        sloc_max=200, fn_length_max=40, avg_fn_length_max=30,
        cyclomatic_per_fn_max=10, cyclomatic_module_max=60,
        nesting_depth_max=3, duplication_pct_max=0.1,
        import_count_max=20, docstring_coverage_min=0.0, mi_min=50
    )

def test_complexity_guard_flags_messy():
    res = evaluate(COMPLEX, _budget())
    assert res["status"] == "fail"
    kinds = {v.get("kind") for v in res["violations"]}
    assert "cyclomatic_per_fn_max" in kinds or "nesting_depth_max" in kinds

def test_debt_score_drops_after_refactor():
    m1 = measure_module(COMPLEX)
    m2 = measure_module(CLEAN)
    assert complexity_debt_units(m2) < complexity_debt_units(m1)
