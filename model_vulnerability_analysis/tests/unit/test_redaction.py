import pytest
from src.reproducibility.logging_redaction import LoggingRedaction
import re
import logging

# Suppress logging during tests to avoid clutter
logging.getLogger().setLevel(logging.CRITICAL)

@pytest.fixture
def redaction_tool():
    return LoggingRedaction()

def test_redact_email(redaction_tool):
    text = "Contact me at test@example.com or user@domain.co.uk."
    redacted = redaction_tool.redact_text(text)
    assert "[EMAIL_REDACTED]" in redacted
    assert "test@example.com" not in redacted
    assert "user@domain.co.uk" not in redacted
    assert len(re.findall(r"\[EMAIL_REDACTED\]", redacted)) == 2

def test_redact_ip_address(redaction_tool):
    text = "Access from 192.168.1.1 and 10.0.0.255 is blocked."
    redacted = redaction_tool.redact_text(text)
    assert "[IP_ADDRESS_REDACTED]" in redacted
    assert "192.168.1.1" not in redacted
    assert "10.0.0.255" not in redacted
    assert len(re.findall(r"\[IP_ADDRESS_REDACTED\]", redacted)) == 2

def test_redact_api_key(redaction_tool):
    text = "My key is sk-abcdefghijklmnopqrstuvwxyz1234567890. Another is ABCDEFGHIJ1234567890."
    redacted = redaction_tool.redact_text(text)
    assert "[API_KEY_REDACTED]" in redacted
    assert "sk-abcdefghijklmnopqrstuvwxyz1234567890" not in redacted
    assert "ABCDEFGHIJ1234567890" not in redacted
    assert len(re.findall(r"\[API_KEY_REDACTED\]", redacted)) == 2

def test_redact_multiple_types(redaction_tool):
    text = "Send details to user@corp.com from 172.16.0.1. My API key is XYZ123ABC."
    redacted = redaction_tool.redact_text(text)
    assert "[EMAIL_REDACTED]" in redacted
    assert "[IP_ADDRESS_REDACTED]" in redacted
    assert "[API_KEY_REDACTED]" in redacted
    assert "user@corp.com" not in redacted
    assert "172.16.0.1" not in redacted
    assert "XYZ123ABC" not in redacted

def test_redact_no_match(redaction_tool):
    text = "This is a normal sentence with no sensitive info."
    redacted = redaction_tool.redact_text(text)
    assert redacted == text

def test_redact_text_no_context(redaction_tool):
    text = "Contact test@example.com."
    redacted = redaction_tool.redact_text(text, preserve_context=False)
    assert "[REDACTED]" in redacted
    assert "test@example.com" not in redacted

def test_redact_log_entry(redaction_tool):
    log_entry = {
        "event": "login",
        "user_email": "admin@secure.org",
        "source_ip": "203.0.113.45",
        "data": {"api_access_token": "secret_token_1234567890abcdef"},
        "message": "User admin@secure.org from 203.0.113.45 attempted login."
    }
    redacted_log_entry = redaction_tool.redact_log_entry(log_entry.copy()) # Pass a copy
    
    assert "[EMAIL_REDACTED]" in redacted_log_entry['user_email']
    assert "[IP_ADDRESS_REDACTED]" in redacted_log_entry['source_ip']
    # The recursive redaction for nested dicts might need more specific handling or pattern.
    # For this simple demo, data dict might not be fully redacted by generic patterns
    # For demonstration, let's assume direct string fields are covered.
    assert "[API_KEY_REDACTED]" in str(redacted_log_entry['data']['api_access_token']) # Check if API key is in string representation
    assert "[EMAIL_REDACTED]" in redacted_log_entry['message']
    assert "[IP_ADDRESS_REDACTED]" in redacted_log_entry['message']
